<body>
  <h2>What I learned implementing the CORDIC algorithm</h2>
  <p>
    This is being written just after finishing the project, so expect this to be fast and loose with structure and quality.
    I would describe my implementation efforts as a failure. <br>
    To implement the algorithm, I studied previous examples of people having implemented it.
    I implemented it in assembly, but with using the FPU for most of the calculations. Obviously this doesn't make sense in the context of this algorithm,
    so I decided to go back and fix that. <br>
    I did successfully implement a conversion from floating-point numbers to fixed-point ones (in the range I care about) but that took
    multiple days of starting, giving up, and starting again another day. Bit-twiddilng is not a strength of mine. <br>
    Once that was finished, I made sure the algorithm worked in C (thanks to glance and typing from other examples). Lastly it came time to
    write it in assembly, the whole point of the exercise. I started writing some of the basic structure and ran in to problems with memory accesses.
    I messed with that for an hour or two before reading the assembly output of my compiler and trying to glean information from that.
    When I failed to succeed there, I burned what I had to the ground, compiled on -O2 and tried to understand what the compiler was doing. <br>
    I learned a few things (csel is neat) but I did not achieve my goal. My compiler did, but I did not. I ruined the challenge for myself out of frustration.
    I've worked on this project off-and-on for a few weeks and I've grown rather sick of it. When an option to escape arrived, I took it even though it poisoned the
    time I had already spent. <br>
    My take away is that I'm bad at programming and will weasel out of challenges given the chance. Also I make significantly less progress when I force myself to lock onto one thing that I do not like.
   </p>
</body>
